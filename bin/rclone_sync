#!/usr/bin/env python3
"""
Rcloneäº¤äº’å¼åŒæ­¥å·¥å…·
ç”¨äºç®¡ç†Cloudflare R2 Bucketä¸æœ¬åœ°æ–‡ä»¶å¤¹çš„åŒæ­¥æ“ä½œ
"""

import os
import subprocess
from pathlib import Path
from typing import List, Optional


class Colors:
    """ç»ˆç«¯é¢œè‰²å®šä¹‰"""

    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKCYAN = "\033[96m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


class RcloneManager:
    """Rcloneæ“ä½œç®¡ç†ç±»"""

    def __init__(self):
        self.remotes: List[str] = []
        self.current_remote: Optional[str] = None
        self.current_bucket: Optional[str] = None
        self.local_directory: Optional[str] = None

    def print_header(self, text: str):
        """æ‰“å°æ ‡é¢˜"""
        print(f"\n{Colors.HEADER}{Colors.BOLD}{'=' * 50}")
        print(f"{text}")
        print(f"{'=' * 50}{Colors.ENDC}")

    def print_success(self, text: str):
        """æ‰“å°æˆåŠŸä¿¡æ¯"""
        print(f"{Colors.OKGREEN}âœ“ {text}{Colors.ENDC}")

    def print_warning(self, text: str):
        """æ‰“å°è­¦å‘Šä¿¡æ¯"""
        print(f"{Colors.WARNING}âš  {text}{Colors.ENDC}")

    def print_error(self, text: str):
        """æ‰“å°é”™è¯¯ä¿¡æ¯"""
        print(f"{Colors.FAIL}âœ— {text}{Colors.ENDC}")

    def print_info(self, text: str):
        """æ‰“å°ä¿¡æ¯"""
        print(f"{Colors.OKCYAN}â„¹ {text}{Colors.ENDC}")

    def check_rclone_installed(self) -> bool:
        """æ£€æŸ¥rcloneæ˜¯å¦å·²å®‰è£…"""
        try:
            result = subprocess.run(
                ["rclone", "version"], capture_output=True, text=True, check=True
            )
            version_line = result.stdout.split("\n")[0]
            self.print_success(f"Rcloneå·²å®‰è£…: {version_line}")
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            self.print_error("Rcloneæœªå®‰è£…æˆ–ä¸åœ¨PATHä¸­")
            self.print_info("è¯·å…ˆå®‰è£…rclone: https://rclone.org/downloads/")
            return False

    def get_remotes(self) -> List[str]:
        """è·å–å·²é…ç½®çš„è¿œç¨‹å­˜å‚¨"""
        try:
            result = subprocess.run(
                ["rclone", "listremotes"], capture_output=True, text=True, check=True
            )
            remotes = [
                remote.strip(":")
                for remote in result.stdout.strip().split("\n")
                if remote
            ]
            self.remotes = remotes
            return remotes
        except subprocess.CalledProcessError as e:
            self.print_error(f"è·å–è¿œç¨‹å­˜å‚¨åˆ—è¡¨å¤±è´¥: {e}")
            return []

    def select_remote(self) -> bool:
        """é€‰æ‹©è¿œç¨‹å­˜å‚¨"""
        remotes = self.get_remotes()

        if not remotes:
            self.print_warning("æœªæ‰¾åˆ°å·²é…ç½®çš„è¿œç¨‹å­˜å‚¨")
            if self.ask_yes_no("æ˜¯å¦éœ€è¦é…ç½®æ–°çš„è¿œç¨‹å­˜å‚¨?"):
                self.configure_remote()
                remotes = self.get_remotes()

        if not remotes:
            return False

        self.print_info("å¯ç”¨çš„è¿œç¨‹å­˜å‚¨:")
        for i, remote in enumerate(remotes, 1):
            print(f"  {i}. {remote}")

        while True:
            try:
                choice = input(f"\nè¯·é€‰æ‹©è¿œç¨‹å­˜å‚¨ (1-{len(remotes)}): ").strip()
                index = int(choice) - 1
                if 0 <= index < len(remotes):
                    self.current_remote = remotes[index]
                    self.print_success(f"å·²é€‰æ‹©è¿œç¨‹å­˜å‚¨: {self.current_remote}")
                    return True
                else:
                    self.print_error("é€‰æ‹©æ— æ•ˆï¼Œè¯·é‡æ–°è¾“å…¥")
            except ValueError:
                self.print_error("è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—")

    def configure_remote(self):
        """é…ç½®æ–°çš„è¿œç¨‹å­˜å‚¨"""
        self.print_info("å¯åŠ¨rcloneé…ç½®å‘å¯¼...")
        subprocess.run(["rclone", "config"])

    def list_buckets(self) -> List[str]:
        """åˆ—å‡ºbucket"""
        if not self.current_remote:
            return []

        try:
            result = subprocess.run(
                ["rclone", "lsd", f"{self.current_remote}:"],
                capture_output=True,
                text=True,
                check=True,
            )
            buckets = []
            for line in result.stdout.strip().split("\n"):
                if line.strip():
                    # è§£æbucketåç§°ï¼ˆå‡è®¾æ ¼å¼ä¸ºæ—¥æœŸ+æ—¶é—´+åç§°ï¼‰
                    parts = line.split()
                    if len(parts) >= 5:
                        bucket_name = parts[-1]
                        buckets.append(bucket_name)
            return buckets
        except subprocess.CalledProcessError as e:
            self.print_error(f"è·å–bucketåˆ—è¡¨å¤±è´¥: {e}")
            return []

    def select_bucket(self) -> bool:
        """é€‰æ‹©bucket"""
        buckets = self.list_buckets()

        if not buckets:
            self.print_warning("æœªæ‰¾åˆ°ä»»ä½•bucket")
            bucket_name = input("è¯·è¾“å…¥bucketåç§°: ").strip()
            if bucket_name:
                self.current_bucket = bucket_name
                return True
            return False

        self.print_info("å¯ç”¨çš„bucket:")
        for i, bucket in enumerate(buckets, 1):
            print(f"  {i}. {bucket}")

        print(f"  {len(buckets) + 1}. æ‰‹åŠ¨è¾“å…¥bucketåç§°")

        while True:
            try:
                choice = input(f"\nè¯·é€‰æ‹©bucket (1-{len(buckets) + 1}): ").strip()
                index = int(choice) - 1

                if 0 <= index < len(buckets):
                    self.current_bucket = buckets[index]
                    self.print_success(f"å·²é€‰æ‹©bucket: {self.current_bucket}")
                    return True
                elif index == len(buckets):
                    bucket_name = input("è¯·è¾“å…¥bucketåç§°: ").strip()
                    if bucket_name:
                        self.current_bucket = bucket_name
                        self.print_success(f"å·²è®¾ç½®bucket: {self.current_bucket}")
                        return True
                else:
                    self.print_error("é€‰æ‹©æ— æ•ˆï¼Œè¯·é‡æ–°è¾“å…¥")
            except ValueError:
                self.print_error("è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—")

    def select_local_directory(self) -> bool:
        """é€‰æ‹©æœ¬åœ°ç›®å½•"""
        self.print_info("è¯·é€‰æ‹©æœ¬åœ°åŒæ­¥ç›®å½•:")

        # å»ºè®®ä¸€äº›å¸¸ç”¨ç›®å½•
        suggestions = [
            str(Path.home() / "Downloads" / "r2_sync"),
            str(Path.home() / "Documents" / "r2_sync"),
            str(Path.cwd() / "r2_sync"),
        ]

        print("å»ºè®®çš„ç›®å½•:")
        for i, path in enumerate(suggestions, 1):
            exists = "âœ“" if Path(path).exists() else "âœ—"
            print(f"  {i}. {path} {exists}")

        print(f"  {len(suggestions) + 1}. è‡ªå®šä¹‰è·¯å¾„")

        while True:
            try:
                choice = input(f"\nè¯·é€‰æ‹© (1-{len(suggestions) + 1}): ").strip()
                index = int(choice) - 1

                if 0 <= index < len(suggestions):
                    self.local_directory = suggestions[index]
                    break
                elif index == len(suggestions):
                    custom_path = input("è¯·è¾“å…¥è‡ªå®šä¹‰è·¯å¾„: ").strip()
                    if custom_path:
                        self.local_directory = os.path.expanduser(custom_path)
                        break
                else:
                    self.print_error("é€‰æ‹©æ— æ•ˆï¼Œè¯·é‡æ–°è¾“å…¥")
            except ValueError:
                self.print_error("è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—")

        # åˆ›å»ºç›®å½•ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
        Path(self.local_directory).mkdir(parents=True, exist_ok=True)
        self.print_success(f"æœ¬åœ°ç›®å½•: {self.local_directory}")
        return True

    def ask_yes_no(self, question: str) -> bool:
        """è¯¢é—®æ˜¯å¦æ“ä½œ"""
        while True:
            answer = input(f"{question} (y/N): ").strip().lower()
            if answer in ["y", "yes"]:
                return True
            elif answer in ["n", "no", ""]:
                return False
            else:
                self.print_error("è¯·è¾“å…¥ y æˆ– n")

    def run_rclone_command(self, args: List[str], dry_run: bool = False) -> bool:
        """è¿è¡Œrcloneå‘½ä»¤"""
        if dry_run:
            args.append("--dry-run")

        self.print_info(f"æ‰§è¡Œå‘½ä»¤: rclone {' '.join(args)}")

        try:
            result = subprocess.run(["rclone"] + args, check=True)
            return result.returncode == 0
        except subprocess.CalledProcessError as e:
            self.print_error(f"å‘½ä»¤æ‰§è¡Œå¤±è´¥: {e}")
            return False

    def sync_from_remote(self, dry_run: bool = False) -> bool:
        """ä»è¿œç¨‹åŒæ­¥åˆ°æœ¬åœ°"""
        if not all([self.current_remote, self.current_bucket, self.local_directory]):
            self.print_error("é…ç½®ä¸å®Œæ•´")
            return False

        remote_path = f"{self.current_remote}:{self.current_bucket}"

        self.print_header(f"ä» {remote_path} åŒæ­¥åˆ°æœ¬åœ°")

        if dry_run:
            self.print_warning("è¿™æ˜¯é¢„è§ˆæ¨¡å¼ï¼Œä¸ä¼šå®é™…æ‰§è¡Œæ“ä½œ")

        args = ["sync", remote_path, self.local_directory, "-v"]
        return self.run_rclone_command(args, dry_run)

    def sync_to_remote(
        self, delete_excluded: bool = False, dry_run: bool = False
    ) -> bool:
        """ä»æœ¬åœ°åŒæ­¥åˆ°è¿œç¨‹"""
        if not all([self.current_remote, self.current_bucket, self.local_directory]):
            self.print_error("é…ç½®ä¸å®Œæ•´")
            return False

        remote_path = f"{self.current_remote}:{self.current_bucket}"

        self.print_header(f"ä»æœ¬åœ°åŒæ­¥åˆ° {remote_path}")

        if delete_excluded:
            self.print_warning("å¯ç”¨åˆ é™¤æ¨¡å¼ï¼šè¿œç¨‹ä¸å­˜åœ¨çš„æ–‡ä»¶å°†è¢«åˆ é™¤")

        if dry_run:
            self.print_warning("è¿™æ˜¯é¢„è§ˆæ¨¡å¼ï¼Œä¸ä¼šå®é™…æ‰§è¡Œæ“ä½œ")

        args = ["sync", self.local_directory, remote_path, "-v"]
        if delete_excluded:
            args.append("--delete-excluded")

        return self.run_rclone_command(args, dry_run)

    def list_local_files(self):
        """åˆ—å‡ºæœ¬åœ°æ–‡ä»¶"""
        if not self.local_directory:
            return

        self.print_header("æœ¬åœ°æ–‡ä»¶åˆ—è¡¨")

        local_path = Path(self.local_directory)
        if not local_path.exists():
            self.print_warning("æœ¬åœ°ç›®å½•ä¸å­˜åœ¨")
            return

        for item in sorted(local_path.rglob("*")):
            if item.is_file():
                rel_path = item.relative_to(local_path)
                size = item.stat().st_size
                print(f"  ğŸ“„ {rel_path} ({self.format_size(size)})")
            elif item.is_dir() and item != local_path:
                rel_path = item.relative_to(local_path)
                print(f"  ğŸ“ {rel_path}/")

    def list_remote_files(self):
        """åˆ—å‡ºè¿œç¨‹æ–‡ä»¶"""
        if not all([self.current_remote, self.current_bucket]):
            return

        remote_path = f"{self.current_remote}:{self.current_bucket}"
        self.print_header(f"è¿œç¨‹æ–‡ä»¶åˆ—è¡¨: {remote_path}")

        try:
            result = subprocess.run(
                ["rclone", "ls", remote_path],
                capture_output=True,
                text=True,
                check=True,
            )

            if result.stdout.strip():
                for line in result.stdout.strip().split("\n"):
                    if line.strip():
                        parts = line.strip().split()
                        if len(parts) >= 2:
                            size = int(parts[0])
                            filename = " ".join(parts[1:])
                            print(f"  ğŸ“„ {filename} ({self.format_size(size)})")
            else:
                self.print_info("è¿œç¨‹bucketä¸ºç©º")

        except subprocess.CalledProcessError as e:
            self.print_error(f"è·å–è¿œç¨‹æ–‡ä»¶åˆ—è¡¨å¤±è´¥: {e}")

    def format_size(self, size: int) -> str:
        """æ ¼å¼åŒ–æ–‡ä»¶å¤§å°"""
        for unit in ["B", "KB", "MB", "GB", "TB"]:
            if size < 1024.0:
                return f"{size:.1f} {unit}"
            size /= 1024.0
        return f"{size:.1f} PB"

    def delete_local_files_interactive(self):
        """äº¤äº’å¼åˆ é™¤æœ¬åœ°æ–‡ä»¶"""
        if not self.local_directory:
            return

        local_path = Path(self.local_directory)
        if not local_path.exists():
            self.print_warning("æœ¬åœ°ç›®å½•ä¸å­˜åœ¨")
            return

        self.print_header("äº¤äº’å¼åˆ é™¤æœ¬åœ°æ–‡ä»¶")
        self.print_warning("è¯·è°¨æ…æ“ä½œï¼Œåˆ é™¤çš„æ–‡ä»¶æ— æ³•æ¢å¤ï¼")

        files = list(local_path.rglob("*"))
        files = [f for f in files if f.is_file()]

        if not files:
            self.print_info("æœ¬åœ°ç›®å½•ä¸ºç©º")
            return

        deleted_count = 0
        for file_path in sorted(files):
            rel_path = file_path.relative_to(local_path)
            size = file_path.stat().st_size

            print(f"\nğŸ“„ {rel_path} ({self.format_size(size)})")
            if self.ask_yes_no("åˆ é™¤æ­¤æ–‡ä»¶?"):
                try:
                    file_path.unlink()
                    self.print_success(f"å·²åˆ é™¤: {rel_path}")
                    deleted_count += 1
                except Exception as e:
                    self.print_error(f"åˆ é™¤å¤±è´¥: {e}")

        self.print_success(f"å…±åˆ é™¤ {deleted_count} ä¸ªæ–‡ä»¶")

    def show_main_menu(self):
        """æ˜¾ç¤ºä¸»èœå•"""
        while True:
            self.print_header("Rclone äº¤äº’å¼åŒæ­¥å·¥å…·")

            print("å½“å‰é…ç½®:")
            print(f"  è¿œç¨‹å­˜å‚¨: {self.current_remote or 'æœªè®¾ç½®'}")
            print(f"  Bucket: {self.current_bucket or 'æœªè®¾ç½®'}")
            print(f"  æœ¬åœ°ç›®å½•: {self.local_directory or 'æœªè®¾ç½®'}")

            print(f"\n{Colors.OKBLUE}æ“ä½œé€‰é¡¹:{Colors.ENDC}")
            print("  1. é€‰æ‹©è¿œç¨‹å­˜å‚¨[Required]")
            print("  2. é€‰æ‹©bucket[Required]")
            print("  3. é€‰æ‹©æœ¬åœ°ç›®å½•")
            print("  4. ä»è¿œç¨‹åŒæ­¥åˆ°æœ¬åœ°")
            print("  5. ä»æœ¬åœ°åŒæ­¥åˆ°è¿œç¨‹")
            print("  6. ä»æœ¬åœ°åŒæ­¥åˆ°è¿œç¨‹ (åˆ é™¤æ¨¡å¼)")
            print("  7. æŸ¥çœ‹æœ¬åœ°æ–‡ä»¶")
            print("  8. æŸ¥çœ‹è¿œç¨‹æ–‡ä»¶")
            print("  9. äº¤äº’å¼åˆ é™¤æœ¬åœ°æ–‡ä»¶")
            print("  10. é¢„è§ˆåŒæ­¥æ“ä½œ")
            print("  0. é€€å‡º")

            choice = input("\nè¯·é€‰æ‹©æ“ä½œ (0-10): ").strip()

            if choice == "0":
                print("å†è§ï¼")
                break
            elif choice == "1":
                self.select_remote()
            elif choice == "2":
                if self.current_remote:
                    self.select_bucket()
                else:
                    self.print_warning("è¯·å…ˆé…ç½®è¿œç¨‹å­˜å‚¨")
            elif choice == "3":
                self.select_local_directory()
            elif choice == "4":
                if self.ask_yes_no("ç¡®è®¤ä»è¿œç¨‹åŒæ­¥åˆ°æœ¬åœ°?"):
                    self.sync_from_remote()
            elif choice == "5":
                if self.ask_yes_no("ç¡®è®¤ä»æœ¬åœ°åŒæ­¥åˆ°è¿œç¨‹?"):
                    self.sync_to_remote()
            elif choice == "6":
                self.print_warning("åˆ é™¤æ¨¡å¼å°†åˆ é™¤è¿œç¨‹ä¸å­˜åœ¨çš„æ–‡ä»¶ï¼")
                if self.ask_yes_no("ç¡®è®¤æ‰§è¡Œåˆ é™¤æ¨¡å¼åŒæ­¥?"):
                    self.sync_to_remote(delete_excluded=True)
            elif choice == "7":
                self.list_local_files()
            elif choice == "8":
                self.list_remote_files()
            elif choice == "9":
                self.delete_local_files_interactive()
            elif choice == "10":
                print("\né¢„è§ˆé€‰é¡¹:")
                print("  1. é¢„è§ˆä»è¿œç¨‹åŒæ­¥åˆ°æœ¬åœ°")
                print("  2. é¢„è§ˆä»æœ¬åœ°åŒæ­¥åˆ°è¿œç¨‹")
                print("  3. é¢„è§ˆä»æœ¬åœ°åŒæ­¥åˆ°è¿œç¨‹ (åˆ é™¤æ¨¡å¼)")

                preview_choice = input("è¯·é€‰æ‹©é¢„è§ˆç±»å‹ (1-3): ").strip()
                if preview_choice == "1":
                    self.sync_from_remote(dry_run=True)
                elif preview_choice == "2":
                    self.sync_to_remote(dry_run=True)
                elif preview_choice == "3":
                    self.sync_to_remote(delete_excluded=True, dry_run=True)
            else:
                self.print_error("æ— æ•ˆçš„é€‰æ‹©")

            input("\næŒ‰å›è½¦é”®ç»§ç»­...")

    def run(self):
        """è¿è¡Œä¸»ç¨‹åº"""
        self.print_header("Rclone äº¤äº’å¼åŒæ­¥å·¥å…·")

        # æ£€æŸ¥rcloneæ˜¯å¦å®‰è£…
        if not self.check_rclone_installed():
            return

        # æ˜¾ç¤ºä¸»èœå•
        self.show_main_menu()


def main():
    """ä¸»å‡½æ•°"""
    try:
        manager = RcloneManager()
        manager.run()
    except KeyboardInterrupt:
        print(f"\n{Colors.WARNING}æ“ä½œè¢«ç”¨æˆ·ä¸­æ–­{Colors.ENDC}")
    except Exception as e:
        print(f"{Colors.FAIL}å‘ç”Ÿé”™è¯¯: {e}{Colors.ENDC}")


if __name__ == "__main__":
    main()
